{"config":{"indexing":"full","lang":["en","fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"index.html","text":"Bases de Donn\u00e9es NoSQL avec Cassandra \u00b6 Objectifs \u00b6 Installer Cassandra et cr\u00e9er une base de donn\u00e9es Interroger une base de donn\u00e9es orient\u00e9e colonnes Prot\u00e9ger la base de donn\u00e9es contre les pannes avec la R\u00e9plication Passer \u00e0 l'\u00e9chelle avec le Sharding Ressources \u00b6 Outils Docker Jupyter Notebook Fichiers de donn\u00e9es (datasets) Sources et r\u00e9f\u00e9rence Documentation Cassandra Datastax Drivers Workshops DataStax DataStax Academy InstaClustr Pr\u00e9sentation de Cassandra \u00b6 Cassndra est un SGDB NoSQL de la cat\u00e9gorie orient\u00e9e colonne ou Wide Column . Il figure parmi les SGBD les plus utilis\u00e9 et le premier de la cat\u00e9gorie Wide column. Source : https://db-engines.com/en/ranking_trend/wide+column+store Source : https://db-engines.com/en/ranking_trend Architecture \u00b6 Un cluster Cassandra est un syst\u00e8me distribu\u00e9 organis\u00e9 selon un mod\u00e8le peer-to-peer sous la forme d'un anneau logique. Cassandra met en oeuvre les techniques de r\u00e9plication et partitionnement de donn\u00e9es afin de garantir la haute disponibilit\u00e9 et la r\u00e9sistance aux pannes. Il offre la possibilit\u00e9 de configurer la coh\u00e9rence par requ\u00eate. Cassandra est utilis\u00e9, en l'associant avec d'autres frameworks, par de grandes entreprises (IBM, Ebay, Spotify, Instagram, ...). La description des diff\u00e9rentes architectures et crit\u00e8res de choix sont d\u00e9crits dans ces \u00e9tudes de cas","title":"Introduction"},{"location":"index.html#bases-de-donnees-nosql-avec-cassandra","text":"","title":"Bases de Donn\u00e9es NoSQL avec Cassandra"},{"location":"index.html#objectifs","text":"Installer Cassandra et cr\u00e9er une base de donn\u00e9es Interroger une base de donn\u00e9es orient\u00e9e colonnes Prot\u00e9ger la base de donn\u00e9es contre les pannes avec la R\u00e9plication Passer \u00e0 l'\u00e9chelle avec le Sharding","title":"Objectifs"},{"location":"index.html#ressources","text":"Outils Docker Jupyter Notebook Fichiers de donn\u00e9es (datasets) Sources et r\u00e9f\u00e9rence Documentation Cassandra Datastax Drivers Workshops DataStax DataStax Academy InstaClustr","title":"Ressources"},{"location":"index.html#presentation-de-cassandra","text":"Cassndra est un SGDB NoSQL de la cat\u00e9gorie orient\u00e9e colonne ou Wide Column . Il figure parmi les SGBD les plus utilis\u00e9 et le premier de la cat\u00e9gorie Wide column. Source : https://db-engines.com/en/ranking_trend/wide+column+store Source : https://db-engines.com/en/ranking_trend","title":"Pr\u00e9sentation de Cassandra"},{"location":"index.html#architecture","text":"Un cluster Cassandra est un syst\u00e8me distribu\u00e9 organis\u00e9 selon un mod\u00e8le peer-to-peer sous la forme d'un anneau logique. Cassandra met en oeuvre les techniques de r\u00e9plication et partitionnement de donn\u00e9es afin de garantir la haute disponibilit\u00e9 et la r\u00e9sistance aux pannes. Il offre la possibilit\u00e9 de configurer la coh\u00e9rence par requ\u00eate. Cassandra est utilis\u00e9, en l'associant avec d'autres frameworks, par de grandes entreprises (IBM, Ebay, Spotify, Instagram, ...). La description des diff\u00e9rentes architectures et crit\u00e8res de choix sont d\u00e9crits dans ces \u00e9tudes de cas","title":"Architecture"},{"location":"Collections_UDT.html","text":"Collections et UDT \u00b6 Objectifs Manipuler les Collections Manipuler les UDT Utiliser une mod\u00e9lisation sp\u00e9cifique NOSQL (d\u00e9normalis\u00e9) Les collections \u00b6 Les collections permettent une repr\u00e9sentation d\u00e9normalis\u00e9e des donn\u00e9es. C'est une solution pour contourner l'absence d'op\u00e9ration de jointure. Cassandra d\u00e9finit 3 types de collections : MAP : repr\u00e9sentant un dictionnaire SET : repr\u00e9sentant un ensemble non ordonn\u00e9es LIST : repr\u00e9sentant un liste ordonn\u00e9e de valeurs Syntaxe \u00b6 D\u00e9claration : MAP '<' cql_type ',' cql_type '>' SET '<' cql_type '>' LIST '<' cql_type '>' Lit\u00e9raux : map_literal :: = '\\{' [ term ':' term ( ',' term : term ) * ] '}' set_literal :: = '\\{' [ term ( ',' term ) * ] '}' list_literal :: = '[' [ term ( ',' term ) * ] ']' Acc\u00e8s : MAP : map_name['key'] LIST : list_name[index] SET : pas d'acc\u00e8s aux \u00e9l\u00e9ments Op\u00e9rations : + : Ajout d'\u00e9l\u00e9ments - : Supression d'\u00e9l\u00e9ments = : Affectation CONTAINS : tester l'appartenance d'un \u00e9l\u00e9ment \u00e0 une collection N\u00e9cessite un index sur la colonne CONTAINS KEY : tester la pr\u00e9sence d'une cl\u00e9 pour le type MAP N\u00e9cessite un index sur la colonne Index LIST et SET : CREATE INDEX index_name ON table_name ( column ); MAP : CREATE INDEX index_name ON table_name ( KEYS ( column )); CREATE INDEX index_name ON table_name ( VALUES ( column )); Exemples \u00b6 Cr\u00e9er une table contenant des collections CREATE TABLE personne ( id INT , nom VARCHAR , prenom VARCHAR , evenements MAP < text , date > , emails SET < text > , enfants LIST < text > , PRIMARY KEY ( id ) ); Cr\u00e9ation d'index CREATE INDEX idx_emails ON personne ( emails ); CREATE INDEX idx_enfants ON personne ( enfants ); CREATE INDEX idx_evenement ON personne ( KEYS ( evenements )); CREATE INDEX idx_evenement ON personne ( VALUES ( evenements )); Insertion de donn\u00e9es INSERT INTO personne ( id , nom , prenom , evenements , emails , enfants ) VALUES ( 1 , 'DELON' , 'Alain' , { 'naissance' : '1935-11-08' } , { 'alain@laposte.fr' , 'alain.delon@laposte.fr' } , [ 'Anthony' , 'Anouchka' , 'Alain' ]); Mise \u00e0 jour -- Ajouter la date du mariage dans les \u00e9v\u00e9nements et supprimer un email et modifier le pr\u00e9nom d'un enfant UPDATE personne SET evenements = evenements + { 'mariage' : '1964-08-13' } , emails = emails - { 'alain@laposte.fr' } , enfants [ 2 ] = 'Alain-Fabien' WHERE id = 1 ; -- Supprimer le premier enfant DELETE enfants [ 0 ] FROM personne WHERE id = 1 ; Recherche -- Chercher la date de naissance des personnes ayant un email alain.delon@laposte.fr SELECT evenements [ 'naissance' ] FROM personne WHERE emails CONTAINS 'alain.delon@laposte.fr' ; -- Chercher les noms et pr\u00e9noms des personnes ayant un \u00e9v\u00e9nement mariage SELECT nom , prenom FROM personne WHERE evenements CONTAINS KEY 'mariage' ; Les types utilisateurs (UDT) \u00b6 Les types d\u00e9finis par l'utilisateur sont semblables aux enregistrements dans les langages de programmation. Il se composnt de champs. Syntaxe \u00b6 La manipulation des UDT dans CQL est similaire \u00e0 celle des tables. D\u00e9finition CREATE TYPE [ IF NOT EXISTS ] < udt_name > ( < champ > < cql_type > , ...); Modification ALTER TYPE < udt_name > ADD < champ > < cql_type > ; ALTER TYPE < udt_name > RENAME < ancien_nom > TO < nouveau_nom > ; Suppression DROP TYPE < udt_name > ; Lit\u00e9raux { champ1 : valeur , ... } UDT et Collections CREATE TABLE T ( collection MAP < text frozen < udt >> ...); Exemple \u00b6 Exemple 1 CREATE TYPE address ( street text , city text , zip text ); CREATE TABLE user ( name text PRIMARY KEY , home address ); INSERT INTO user ( name , home ) VALUES ( 'z3 Pr3z1den7' , { street : '1600 Pennsylvania Ave NW' , city : 'Washington' , zip : '20500' } ); Exemple 2 CREATE TYPE phone ( country_code int , number text , ); CREATE TYPE address ( street text , city text , zip text , phones map < text , phone > ); CREATE TABLE user ( name text PRIMARY KEY , addresses map < text , frozen < address >> ); INSERT INTO user ( name , addresses ) VALUES ( 'z3 Pr3z1den7' , { 'home' : { street : '1600 Pennsylvania Ave NW' , city : 'Washington' , zip : '20500' , phones : { 'cell' : { country_code : 1 , number : '202 456\u20101111' } , 'landline' : { country_code : 1 , number : '...' } } } , 'work' : { street : '1600 Pennsylvania Ave NW' , city : 'Washington' , zip : '20500' , phones : { 'fax' : { country_code : 1 , number : '...' } } } } ); Exercice \u00b6 Dans l\u2019archive fournie avec la section interrogation , nous allons utiliser le fichier InspectionsRestaurant.json dont la structure JSON est comme suit : { \"idRestaurant\" : 40373938 , \"restaurant\" : { \"name\" : \"IHOP\" , \"borough\" : \"BRONX\" , \"buildingnum\" : \"5655\" , \"street\" : \"BROADWAY\" , \"zipcode\" : \"10463\" , \"phone\" : \"7185494565\" , \"cuisineType\" : \"American\" }, \"inspectionDate\" : \"2016-08-16\" , \"violationCode\" : \"04L\" , \"violationDescription\" : \"Evidence of mice or live mice present in facility's food and/or non-food areas.\" , \"criticalFlag\" : \"Critical\" , \"score\" : 15 , \"grade\" : \"\" } Partie 1 \u00b6 D\u00e9finir le mod\u00e8le de document associant les restaurants et leurs inspections, en utilisant les types imbriqu\u00e9s, et cr\u00e9er la table InspectionRestaurant selon le format JSON pr\u00e9c\u00e9dent. Ins\u00e9rer un document dans la table. Faire l\u2019import avec l\u2019utilitaire d\u2019insertion de documents JSON. copier le fichier JSON et JAR dans le container importer avec l'utilitaire selon la syntaxe suivante java -jar JSonFile2Cassandra [ -host <host> ] [ -port <port> ] [ -keyspace <keyspace> ] [ -columnFamily <columnFamily> ] [ file ] 4. Cr\u00e9er un index sur le Grade de la table InspectionRestaurant, puis trouver les restaurants ayant re\u00e7u le grade \u201cA\u201d au moins une fois. Partie 2 \u00b6 Maintenant, on veut pouvoir rechercher les restaurants par leur quartier (borough). Est-ce possible sur le sch\u00e9ma pr\u00e9c\u00e9dent ? Proposer une mod\u00e9lisation adapt\u00e9e, et cr\u00e9er la table. Utiliser cette fois la solution du map avec la date d\u2019insertion comme cl\u00e9. Ins\u00e9rer des donn\u00e9es dans la nouvelle table, soit directement, soit avec l\u2019utilitaire d\u2019import. Trouver tous les restaurants du Bronx. Maintenant, on veut, sur cette seconde table, trouver tous les restaurants ayant re\u00e7u une note \u201cA\u201d. Est-ce possible ? Chercher une solution permise par le fait que nous avons utilis\u00e9 le type map.","title":"Collections et UDT"},{"location":"Collections_UDT.html#collections-et-udt","text":"Objectifs Manipuler les Collections Manipuler les UDT Utiliser une mod\u00e9lisation sp\u00e9cifique NOSQL (d\u00e9normalis\u00e9)","title":"Collections et UDT"},{"location":"Collections_UDT.html#les-collections","text":"Les collections permettent une repr\u00e9sentation d\u00e9normalis\u00e9e des donn\u00e9es. C'est une solution pour contourner l'absence d'op\u00e9ration de jointure. Cassandra d\u00e9finit 3 types de collections : MAP : repr\u00e9sentant un dictionnaire SET : repr\u00e9sentant un ensemble non ordonn\u00e9es LIST : repr\u00e9sentant un liste ordonn\u00e9e de valeurs","title":"Les collections"},{"location":"Collections_UDT.html#syntaxe","text":"D\u00e9claration : MAP '<' cql_type ',' cql_type '>' SET '<' cql_type '>' LIST '<' cql_type '>' Lit\u00e9raux : map_literal :: = '\\{' [ term ':' term ( ',' term : term ) * ] '}' set_literal :: = '\\{' [ term ( ',' term ) * ] '}' list_literal :: = '[' [ term ( ',' term ) * ] ']' Acc\u00e8s : MAP : map_name['key'] LIST : list_name[index] SET : pas d'acc\u00e8s aux \u00e9l\u00e9ments Op\u00e9rations : + : Ajout d'\u00e9l\u00e9ments - : Supression d'\u00e9l\u00e9ments = : Affectation CONTAINS : tester l'appartenance d'un \u00e9l\u00e9ment \u00e0 une collection N\u00e9cessite un index sur la colonne CONTAINS KEY : tester la pr\u00e9sence d'une cl\u00e9 pour le type MAP N\u00e9cessite un index sur la colonne Index LIST et SET : CREATE INDEX index_name ON table_name ( column ); MAP : CREATE INDEX index_name ON table_name ( KEYS ( column )); CREATE INDEX index_name ON table_name ( VALUES ( column ));","title":"Syntaxe"},{"location":"Collections_UDT.html#exemples","text":"Cr\u00e9er une table contenant des collections CREATE TABLE personne ( id INT , nom VARCHAR , prenom VARCHAR , evenements MAP < text , date > , emails SET < text > , enfants LIST < text > , PRIMARY KEY ( id ) ); Cr\u00e9ation d'index CREATE INDEX idx_emails ON personne ( emails ); CREATE INDEX idx_enfants ON personne ( enfants ); CREATE INDEX idx_evenement ON personne ( KEYS ( evenements )); CREATE INDEX idx_evenement ON personne ( VALUES ( evenements )); Insertion de donn\u00e9es INSERT INTO personne ( id , nom , prenom , evenements , emails , enfants ) VALUES ( 1 , 'DELON' , 'Alain' , { 'naissance' : '1935-11-08' } , { 'alain@laposte.fr' , 'alain.delon@laposte.fr' } , [ 'Anthony' , 'Anouchka' , 'Alain' ]); Mise \u00e0 jour -- Ajouter la date du mariage dans les \u00e9v\u00e9nements et supprimer un email et modifier le pr\u00e9nom d'un enfant UPDATE personne SET evenements = evenements + { 'mariage' : '1964-08-13' } , emails = emails - { 'alain@laposte.fr' } , enfants [ 2 ] = 'Alain-Fabien' WHERE id = 1 ; -- Supprimer le premier enfant DELETE enfants [ 0 ] FROM personne WHERE id = 1 ; Recherche -- Chercher la date de naissance des personnes ayant un email alain.delon@laposte.fr SELECT evenements [ 'naissance' ] FROM personne WHERE emails CONTAINS 'alain.delon@laposte.fr' ; -- Chercher les noms et pr\u00e9noms des personnes ayant un \u00e9v\u00e9nement mariage SELECT nom , prenom FROM personne WHERE evenements CONTAINS KEY 'mariage' ;","title":"Exemples"},{"location":"Collections_UDT.html#les-types-utilisateurs-udt","text":"Les types d\u00e9finis par l'utilisateur sont semblables aux enregistrements dans les langages de programmation. Il se composnt de champs.","title":"Les types utilisateurs (UDT)"},{"location":"Collections_UDT.html#syntaxe_1","text":"La manipulation des UDT dans CQL est similaire \u00e0 celle des tables. D\u00e9finition CREATE TYPE [ IF NOT EXISTS ] < udt_name > ( < champ > < cql_type > , ...); Modification ALTER TYPE < udt_name > ADD < champ > < cql_type > ; ALTER TYPE < udt_name > RENAME < ancien_nom > TO < nouveau_nom > ; Suppression DROP TYPE < udt_name > ; Lit\u00e9raux { champ1 : valeur , ... } UDT et Collections CREATE TABLE T ( collection MAP < text frozen < udt >> ...);","title":"Syntaxe"},{"location":"Collections_UDT.html#exemple","text":"Exemple 1 CREATE TYPE address ( street text , city text , zip text ); CREATE TABLE user ( name text PRIMARY KEY , home address ); INSERT INTO user ( name , home ) VALUES ( 'z3 Pr3z1den7' , { street : '1600 Pennsylvania Ave NW' , city : 'Washington' , zip : '20500' } ); Exemple 2 CREATE TYPE phone ( country_code int , number text , ); CREATE TYPE address ( street text , city text , zip text , phones map < text , phone > ); CREATE TABLE user ( name text PRIMARY KEY , addresses map < text , frozen < address >> ); INSERT INTO user ( name , addresses ) VALUES ( 'z3 Pr3z1den7' , { 'home' : { street : '1600 Pennsylvania Ave NW' , city : 'Washington' , zip : '20500' , phones : { 'cell' : { country_code : 1 , number : '202 456\u20101111' } , 'landline' : { country_code : 1 , number : '...' } } } , 'work' : { street : '1600 Pennsylvania Ave NW' , city : 'Washington' , zip : '20500' , phones : { 'fax' : { country_code : 1 , number : '...' } } } } );","title":"Exemple"},{"location":"Collections_UDT.html#exercice","text":"Dans l\u2019archive fournie avec la section interrogation , nous allons utiliser le fichier InspectionsRestaurant.json dont la structure JSON est comme suit : { \"idRestaurant\" : 40373938 , \"restaurant\" : { \"name\" : \"IHOP\" , \"borough\" : \"BRONX\" , \"buildingnum\" : \"5655\" , \"street\" : \"BROADWAY\" , \"zipcode\" : \"10463\" , \"phone\" : \"7185494565\" , \"cuisineType\" : \"American\" }, \"inspectionDate\" : \"2016-08-16\" , \"violationCode\" : \"04L\" , \"violationDescription\" : \"Evidence of mice or live mice present in facility's food and/or non-food areas.\" , \"criticalFlag\" : \"Critical\" , \"score\" : 15 , \"grade\" : \"\" }","title":"Exercice"},{"location":"Collections_UDT.html#partie-1","text":"D\u00e9finir le mod\u00e8le de document associant les restaurants et leurs inspections, en utilisant les types imbriqu\u00e9s, et cr\u00e9er la table InspectionRestaurant selon le format JSON pr\u00e9c\u00e9dent. Ins\u00e9rer un document dans la table. Faire l\u2019import avec l\u2019utilitaire d\u2019insertion de documents JSON. copier le fichier JSON et JAR dans le container importer avec l'utilitaire selon la syntaxe suivante java -jar JSonFile2Cassandra [ -host <host> ] [ -port <port> ] [ -keyspace <keyspace> ] [ -columnFamily <columnFamily> ] [ file ] 4. Cr\u00e9er un index sur le Grade de la table InspectionRestaurant, puis trouver les restaurants ayant re\u00e7u le grade \u201cA\u201d au moins une fois.","title":"Partie 1"},{"location":"Collections_UDT.html#partie-2","text":"Maintenant, on veut pouvoir rechercher les restaurants par leur quartier (borough). Est-ce possible sur le sch\u00e9ma pr\u00e9c\u00e9dent ? Proposer une mod\u00e9lisation adapt\u00e9e, et cr\u00e9er la table. Utiliser cette fois la solution du map avec la date d\u2019insertion comme cl\u00e9. Ins\u00e9rer des donn\u00e9es dans la nouvelle table, soit directement, soit avec l\u2019utilitaire d\u2019import. Trouver tous les restaurants du Bronx. Maintenant, on veut, sur cette seconde table, trouver tous les restaurants ayant re\u00e7u une note \u201cA\u201d. Est-ce possible ? Chercher une solution permise par le fait que nous avons utilis\u00e9 le type map.","title":"Partie 2"},{"location":"cluster.html","text":"Cluster Cassandra \u00b6 Cr\u00e9er un cluster Cassandra \u00b6 La cr\u00e9ation d'un cluster avec Docker est simple. En effet, pour configurer les noeuds, il existe 2 m\u00e9thodes : Utiliser des fichiers de configuration cassandra.yaml et les monter comme volumes (avec l'option -v). Utiliser les variables d'environnements (option -e) pour modifier les param\u00e8tres de configuration par d\u00e9faut. Dans ce quit suit nous utilisons les variables d'environnement dont : CASSANDRA_HOST : nom du noeud ou son adresse IP. CASSANDRA_CLUSTER_NAME : Nom du cluster ququel appartient le noeud. CASSANDRA_SEEDS : les noeuds du cluster Cassandra permettant le d\u00e9marrage du cluster (bootstrap) contact\u00e9s par les nouveaux noeuds. CASSANDRA_ENDPOINT_SNITCH : Nom du Snitch (d\u00e9termine les Racks et Datacenters auxquels apprtiennent les noeuds). Par d\u00e9faut SimpleSnitch. CASSANDRA_PASSWORD : Mot de passe pour l'utilisateur. Par d\u00e9fault: cassandra. CASSANDRA_PASSWORD_SEEDER : Un noeud par cluster qui permet de changer le mot de passe lors de l'initialisation. CASSANDRA_NUM_TOKENS : nombre de tokens g\u00e9r\u00e9s par un noeud. ... Cr\u00e9er un r\u00e9seau Docker docker network create cassandra_network Cr\u00e9er le premier noeud docker run -d --name cass1 \\ --net = cassandra_network \\ -p 9042 :9042 \\ -e CASSANDRA_CLUSTER_NAME = cassandra-cluster \\ -e CASSANDRA_NUM_TOKENS = 1 \\ -e CASSANDRA_PASSWORD_SEEDER = yes \\ -e CASSANDRA_PASSWORD = mypassword \\ cassandra:4.0.6 Les noeuds appartenant au m\u00eame cluster ont le m\u00eame CASSANDRA_CLUSTER_NAME . Cr\u00e9er 2 autres noeuds docker run -d --name cass2 \\ --net = cassandra_network \\ -e CASSANDRA_CLUSTER_NAME = cassandra-cluster \\ -e CASSANDRA_NUM_TOKENS = 1 \\ -e CASSANDRA_SEEDS = cass1 \\ -e CASSANDRA_PASSWORD = mypassword \\ cassandra:4.0.6 docker run -d --name cass3 \\ --net = cassandra_network \\ -e CASSANDRA_CLUSTER_NAME = cassandra-cluster \\ -e CASSANDRA_NUM_TOKENS = 1 \\ -e CASSANDRA_SEEDS = cass1 \\ -e CASSANDRA_PASSWORD = mypassword \\ cassandra:4.0.6 Maintenant, vous avez un cluster de 3 noeuds. Surveillance du cluster \u00b6 V\u00e9rifier l'\u00e9tat du cluster docke exec cass1 nodetool status Voir la r\u00e9partition des tokens docke exec cass1 nodetool ring R\u00e9cup\u00e9rer les statitiques sur les tables docker exec cass1 nodetool tablestats JMX Cassandra est compatible avec JMX. Un standard qui permet de publier des m\u00e9triques sur l'utilisation des ressources par Cassandra. Des outils VisualVM permettent de visualiser ces mesures. Toutefois, il faut pr\u00e9parer le container Docker pour une connexion externe JMX. Avec docker 1. Cr\u00e9er un fichier jmxremote.password contenant une ligne : controlRole jmxpassword 2. D\u00e9marrer le container avec la commande docker run --name containerized-cassandra -p 7199 :7199 -v jmxremote.password:/etc/cassandra/jmxremote.password -e LOCAL_JMX = 'no' cassandra:4.0.6 3. Se connecter avec VisualVM sur localhost:7199 avec les param\u00e8tres d'authentification controlRole et jmxpassword Mise en oeuvre de la r\u00e9plication \u00b6 Se connecter \u00e0 un noeud du cluster avec cqlsh docker exec -it cass1 cqlsh Cr\u00e9er un Keyspace avec un facteur de r\u00e9plication de 3 et ins\u00e9rer des donn\u00e9es CREATE KEYSPACE IF NOT EXISTS test_replication WITH REPLICATION = { 'class' : 'SimpleStrategy' , 'replication_factor' : 3 } ; USE test_replication ; CREATE TABLE cours ( id INT , nom VARCHAR , coefficient FLOAT , PRIMARY KEY ( id ) ); INSERT INTO cours ( id , nom , coefficient ) VALUES ( 1 , 'NoSQL' , 1 . 5 ); V\u00e9rifier la r\u00e9plication des lignes : Afficher les noeuds ayant une copie du cours 1 docker exec cass1 nodetool getendpoints test_replication cours 1 pour un facteur de r\u00e9plication 3, 3 noeuds diff\u00e9rents doivent \u00eatre affich\u00e9s V\u00e9rifier les \u00e9critures docker exec cass1 nodetool cfstats test_replication docker exec cass2 nodetool cfstats test_replication docker exec cass3 nodetool cfstats test_replication La valeur de Write Count doit \u00eatre \u00e9gale \u00e0 1 pour trois noeuds cons\u00e9cutifs sur l'anneau et 0 pour les autres. V\u00e9rifier la disponibilit\u00e9 des donn\u00e9es \u00e0 partir de tous les noeuds Se connecter \u00e0 un noeud avec Write Count \u00e9gal \u00e0 0 et acc\u00e9der aux donn\u00e9es. Si cass3 ne contient pas les noeuds : docker exec -it cass3 cqlsh puis USE test_replication ; SELECT * FROM cours ; R\u00e9parer l'\u00e9tat de r\u00e9plication Pour forcer la synchronisation des donn\u00e9es d'un Keyspace : docker exec cass1 nodetool repair test_replication Mise en oeuvre du Sharding \u00b6 V\u00e9rifier les token attribu\u00e9 aux noeuds du cluster docker exec cass1 nodetool ring Un r\u00e9sultat possible est comme l'aper\u00e7u suivant : root@ab7a361c7e9b:/# nodetool ring Datacenter: datacenter1 ========== Address Rack Status State Load Owns Token 6081392343852191785 172 .26.0.2 rack1 Up Normal 96 .15 KiB 63 .08% -5126891207358132333 172 .26.0.4 rack1 Up Normal 139 .66 KiB 76 .16% 1683513220770616142 172 .26.0.3 rack1 Up Normal 96 .06 KiB 60 .76% 6081392343852191785 Les noeuds de l'anneau virtuel sont 172.26.0.2 (cass1) puis 172.26.0.4 (cass3) et 172.26.0.3 (cass2) ayant respectivement les tokens -5126891207358132333, 1683513220770616142 et 1683513220770616142 Adresse IP Pour obtenir l'adresse IP du container cass1 docker exec cass1 ip addr ou docker inspect -f '{{ .NetworkSettings.Networks.cassandra_network.IPAddress }}' cass1 Ins\u00e9rer d'autres lignes docker exec -it cass1 cqlsh puis USE test_replication ; INSERT INTO cours ( id , nom , coefficient ) VALUES ( 10 , 'Python' , 1 ); INSERT INTO cours ( id , nom , coefficient ) VALUES ( 100 , 'Statistiques' , 1 . 5 ); Afficher les tokens des donn\u00e9es ins\u00e9r\u00e9es select token ( id ), id from test_replication . cours ; system . token ( id ) | id ----------------------+----- - 6715243485458697746 | 10 - 4069959284402364209 | 1 2008715943680221220 | 100 ( 3 rows ) En examinant les valeurs, l'affectation des lignes selin l'id (cl\u00e9 primaire) aux noeuds du cluster est obtenu ainsi : token(1) = -4069959284402364209 dans ]-5126891207358132333, 1683513220770616142[ ==> noeud 172.26.0.4 token(10) = -6715243485458697746 < -5126891207358132333 ==> noeud 172.26.0.2 token (100) = 2008715943680221220 dans ]1683513220770616142, 6081392343852191785[ ==> noeud 172.26.0.3 Sharding et replication Vu que la r\u00e9plication est aussi activ\u00e9e alors chaque ligne est r\u00e9pliqu\u00e9e dans le noeud suivant sur l'anneau. docker exec -it cass1 bash root@ab7a361c7e9b:/# nodetool getendpoints test_replication cours 1 172 .26.0.4 172 .26.0.3 root@ab7a361c7e9b:/# nodetool getendpoints test_replication cours 10 172 .26.0.2 172 .26.0.4 root@ab7a361c7e9b:/# nodetool getendpoints test_replication cours 100 172 .26.0.3 172 .26.0.2 Transactions et coh\u00e9rence \u00b6 V\u00e9rifier le niveau de coh\u00e9rance par d\u00e9faut docker exec -it cass1 cqlsh puis CONSISTENCY Current consistency level is ONE . Le niveau de coh\u00e9rence est ONE. Niveaux de coh\u00e9rence Cassandra ONE (TWO, THREE) : Le coordinateur re\u00e7oit la r\u00e9ponse du premier r\u00e9plica (ou de deux, ou de trois) et la renvoie au client. Cette strat\u00e9gie assure une haute disponibilit\u00e9, mais au risque de renvoyer un document qui n\u2019est pas synchronis\u00e9 avec les autres r\u00e9plicas. Dans ce cas, la coh\u00e9rence des donn\u00e9es n\u2019est pas assur\u00e9e QUORUM : Le coordinateur re\u00e7oit la r\u00e9ponse de au moins r\u00e9plicas. C\u2019est la strat\u00e9gie qui repr\u00e9sente le meilleur compromis ALL : Le coordinateur re\u00e7oit la r\u00e9ponse de tous les r\u00e9plicas. Si un r\u00e9plica ne r\u00e9pond pas, alors la requ\u00eate sera en \u00e9chec. C\u2019est la strat\u00e9gie qui assure la meilleure coh\u00e9rence des donn\u00e9es, mais au prix de la disponibilit\u00e9 du syst\u00e8me Arr\u00eater les noeuds docker pause cass2 cass3 docker exec cass1 nodetool ring Mettre le niveau de coh\u00e9rence \u00e0 ALL et interroger les donn\u00e9es docker exec -it cass1 cqlsh puis use test_replication ; consistency all ; select * from cours where id = 1 ; select * from cours where id = 10 ; select * from cours where id = 100 ; Comme attendu, la r\u00e9ponse renvoy\u00e9e au client est une erreur pour toutes les requ\u00eates. Tester de nouveau le iveau ONE docker exec -it cass1 cqlsh puis use test_replication ; consistency one ; select * from cours where id = 1 ; select * from cours where id = 10 ; select * from cours where id = 100 ; Vu que le noeud cass1 contient les cours 10 et 100 (voir sharding), seule la premi\u00e8re requ\u00eate g\u00e9n\u00e8re une erreur.","title":"Cluster"},{"location":"cluster.html#cluster-cassandra","text":"","title":"Cluster Cassandra"},{"location":"cluster.html#creer-un-cluster-cassandra","text":"La cr\u00e9ation d'un cluster avec Docker est simple. En effet, pour configurer les noeuds, il existe 2 m\u00e9thodes : Utiliser des fichiers de configuration cassandra.yaml et les monter comme volumes (avec l'option -v). Utiliser les variables d'environnements (option -e) pour modifier les param\u00e8tres de configuration par d\u00e9faut. Dans ce quit suit nous utilisons les variables d'environnement dont : CASSANDRA_HOST : nom du noeud ou son adresse IP. CASSANDRA_CLUSTER_NAME : Nom du cluster ququel appartient le noeud. CASSANDRA_SEEDS : les noeuds du cluster Cassandra permettant le d\u00e9marrage du cluster (bootstrap) contact\u00e9s par les nouveaux noeuds. CASSANDRA_ENDPOINT_SNITCH : Nom du Snitch (d\u00e9termine les Racks et Datacenters auxquels apprtiennent les noeuds). Par d\u00e9faut SimpleSnitch. CASSANDRA_PASSWORD : Mot de passe pour l'utilisateur. Par d\u00e9fault: cassandra. CASSANDRA_PASSWORD_SEEDER : Un noeud par cluster qui permet de changer le mot de passe lors de l'initialisation. CASSANDRA_NUM_TOKENS : nombre de tokens g\u00e9r\u00e9s par un noeud. ... Cr\u00e9er un r\u00e9seau Docker docker network create cassandra_network Cr\u00e9er le premier noeud docker run -d --name cass1 \\ --net = cassandra_network \\ -p 9042 :9042 \\ -e CASSANDRA_CLUSTER_NAME = cassandra-cluster \\ -e CASSANDRA_NUM_TOKENS = 1 \\ -e CASSANDRA_PASSWORD_SEEDER = yes \\ -e CASSANDRA_PASSWORD = mypassword \\ cassandra:4.0.6 Les noeuds appartenant au m\u00eame cluster ont le m\u00eame CASSANDRA_CLUSTER_NAME . Cr\u00e9er 2 autres noeuds docker run -d --name cass2 \\ --net = cassandra_network \\ -e CASSANDRA_CLUSTER_NAME = cassandra-cluster \\ -e CASSANDRA_NUM_TOKENS = 1 \\ -e CASSANDRA_SEEDS = cass1 \\ -e CASSANDRA_PASSWORD = mypassword \\ cassandra:4.0.6 docker run -d --name cass3 \\ --net = cassandra_network \\ -e CASSANDRA_CLUSTER_NAME = cassandra-cluster \\ -e CASSANDRA_NUM_TOKENS = 1 \\ -e CASSANDRA_SEEDS = cass1 \\ -e CASSANDRA_PASSWORD = mypassword \\ cassandra:4.0.6 Maintenant, vous avez un cluster de 3 noeuds.","title":"Cr\u00e9er un cluster Cassandra"},{"location":"cluster.html#surveillance-du-cluster","text":"V\u00e9rifier l'\u00e9tat du cluster docke exec cass1 nodetool status Voir la r\u00e9partition des tokens docke exec cass1 nodetool ring R\u00e9cup\u00e9rer les statitiques sur les tables docker exec cass1 nodetool tablestats JMX Cassandra est compatible avec JMX. Un standard qui permet de publier des m\u00e9triques sur l'utilisation des ressources par Cassandra. Des outils VisualVM permettent de visualiser ces mesures. Toutefois, il faut pr\u00e9parer le container Docker pour une connexion externe JMX. Avec docker 1. Cr\u00e9er un fichier jmxremote.password contenant une ligne : controlRole jmxpassword 2. D\u00e9marrer le container avec la commande docker run --name containerized-cassandra -p 7199 :7199 -v jmxremote.password:/etc/cassandra/jmxremote.password -e LOCAL_JMX = 'no' cassandra:4.0.6 3. Se connecter avec VisualVM sur localhost:7199 avec les param\u00e8tres d'authentification controlRole et jmxpassword","title":"Surveillance du cluster"},{"location":"cluster.html#mise-en-oeuvre-de-la-replication","text":"Se connecter \u00e0 un noeud du cluster avec cqlsh docker exec -it cass1 cqlsh Cr\u00e9er un Keyspace avec un facteur de r\u00e9plication de 3 et ins\u00e9rer des donn\u00e9es CREATE KEYSPACE IF NOT EXISTS test_replication WITH REPLICATION = { 'class' : 'SimpleStrategy' , 'replication_factor' : 3 } ; USE test_replication ; CREATE TABLE cours ( id INT , nom VARCHAR , coefficient FLOAT , PRIMARY KEY ( id ) ); INSERT INTO cours ( id , nom , coefficient ) VALUES ( 1 , 'NoSQL' , 1 . 5 ); V\u00e9rifier la r\u00e9plication des lignes : Afficher les noeuds ayant une copie du cours 1 docker exec cass1 nodetool getendpoints test_replication cours 1 pour un facteur de r\u00e9plication 3, 3 noeuds diff\u00e9rents doivent \u00eatre affich\u00e9s V\u00e9rifier les \u00e9critures docker exec cass1 nodetool cfstats test_replication docker exec cass2 nodetool cfstats test_replication docker exec cass3 nodetool cfstats test_replication La valeur de Write Count doit \u00eatre \u00e9gale \u00e0 1 pour trois noeuds cons\u00e9cutifs sur l'anneau et 0 pour les autres. V\u00e9rifier la disponibilit\u00e9 des donn\u00e9es \u00e0 partir de tous les noeuds Se connecter \u00e0 un noeud avec Write Count \u00e9gal \u00e0 0 et acc\u00e9der aux donn\u00e9es. Si cass3 ne contient pas les noeuds : docker exec -it cass3 cqlsh puis USE test_replication ; SELECT * FROM cours ; R\u00e9parer l'\u00e9tat de r\u00e9plication Pour forcer la synchronisation des donn\u00e9es d'un Keyspace : docker exec cass1 nodetool repair test_replication","title":"Mise en oeuvre de la r\u00e9plication"},{"location":"cluster.html#mise-en-oeuvre-du-sharding","text":"V\u00e9rifier les token attribu\u00e9 aux noeuds du cluster docker exec cass1 nodetool ring Un r\u00e9sultat possible est comme l'aper\u00e7u suivant : root@ab7a361c7e9b:/# nodetool ring Datacenter: datacenter1 ========== Address Rack Status State Load Owns Token 6081392343852191785 172 .26.0.2 rack1 Up Normal 96 .15 KiB 63 .08% -5126891207358132333 172 .26.0.4 rack1 Up Normal 139 .66 KiB 76 .16% 1683513220770616142 172 .26.0.3 rack1 Up Normal 96 .06 KiB 60 .76% 6081392343852191785 Les noeuds de l'anneau virtuel sont 172.26.0.2 (cass1) puis 172.26.0.4 (cass3) et 172.26.0.3 (cass2) ayant respectivement les tokens -5126891207358132333, 1683513220770616142 et 1683513220770616142 Adresse IP Pour obtenir l'adresse IP du container cass1 docker exec cass1 ip addr ou docker inspect -f '{{ .NetworkSettings.Networks.cassandra_network.IPAddress }}' cass1 Ins\u00e9rer d'autres lignes docker exec -it cass1 cqlsh puis USE test_replication ; INSERT INTO cours ( id , nom , coefficient ) VALUES ( 10 , 'Python' , 1 ); INSERT INTO cours ( id , nom , coefficient ) VALUES ( 100 , 'Statistiques' , 1 . 5 ); Afficher les tokens des donn\u00e9es ins\u00e9r\u00e9es select token ( id ), id from test_replication . cours ; system . token ( id ) | id ----------------------+----- - 6715243485458697746 | 10 - 4069959284402364209 | 1 2008715943680221220 | 100 ( 3 rows ) En examinant les valeurs, l'affectation des lignes selin l'id (cl\u00e9 primaire) aux noeuds du cluster est obtenu ainsi : token(1) = -4069959284402364209 dans ]-5126891207358132333, 1683513220770616142[ ==> noeud 172.26.0.4 token(10) = -6715243485458697746 < -5126891207358132333 ==> noeud 172.26.0.2 token (100) = 2008715943680221220 dans ]1683513220770616142, 6081392343852191785[ ==> noeud 172.26.0.3 Sharding et replication Vu que la r\u00e9plication est aussi activ\u00e9e alors chaque ligne est r\u00e9pliqu\u00e9e dans le noeud suivant sur l'anneau. docker exec -it cass1 bash root@ab7a361c7e9b:/# nodetool getendpoints test_replication cours 1 172 .26.0.4 172 .26.0.3 root@ab7a361c7e9b:/# nodetool getendpoints test_replication cours 10 172 .26.0.2 172 .26.0.4 root@ab7a361c7e9b:/# nodetool getendpoints test_replication cours 100 172 .26.0.3 172 .26.0.2","title":"Mise en oeuvre du Sharding"},{"location":"cluster.html#transactions-et-coherence","text":"V\u00e9rifier le niveau de coh\u00e9rance par d\u00e9faut docker exec -it cass1 cqlsh puis CONSISTENCY Current consistency level is ONE . Le niveau de coh\u00e9rence est ONE. Niveaux de coh\u00e9rence Cassandra ONE (TWO, THREE) : Le coordinateur re\u00e7oit la r\u00e9ponse du premier r\u00e9plica (ou de deux, ou de trois) et la renvoie au client. Cette strat\u00e9gie assure une haute disponibilit\u00e9, mais au risque de renvoyer un document qui n\u2019est pas synchronis\u00e9 avec les autres r\u00e9plicas. Dans ce cas, la coh\u00e9rence des donn\u00e9es n\u2019est pas assur\u00e9e QUORUM : Le coordinateur re\u00e7oit la r\u00e9ponse de au moins r\u00e9plicas. C\u2019est la strat\u00e9gie qui repr\u00e9sente le meilleur compromis ALL : Le coordinateur re\u00e7oit la r\u00e9ponse de tous les r\u00e9plicas. Si un r\u00e9plica ne r\u00e9pond pas, alors la requ\u00eate sera en \u00e9chec. C\u2019est la strat\u00e9gie qui assure la meilleure coh\u00e9rence des donn\u00e9es, mais au prix de la disponibilit\u00e9 du syst\u00e8me Arr\u00eater les noeuds docker pause cass2 cass3 docker exec cass1 nodetool ring Mettre le niveau de coh\u00e9rence \u00e0 ALL et interroger les donn\u00e9es docker exec -it cass1 cqlsh puis use test_replication ; consistency all ; select * from cours where id = 1 ; select * from cours where id = 10 ; select * from cours where id = 100 ; Comme attendu, la r\u00e9ponse renvoy\u00e9e au client est une erreur pour toutes les requ\u00eates. Tester de nouveau le iveau ONE docker exec -it cass1 cqlsh puis use test_replication ; consistency one ; select * from cours where id = 1 ; select * from cours where id = 10 ; select * from cours where id = 100 ; Vu que le noeud cass1 contient les cours 10 et 100 (voir sharding), seule la premi\u00e8re requ\u00eate g\u00e9n\u00e8re une erreur.","title":"Transactions et coh\u00e9rence"},{"location":"installation.html","text":"Installation de Cassandra \u00b6 Cassandra avec Docker \u00b6 Installation \u00b6 T\u00e9l\u00e9charger l'image officielle de Cassandra (ici la version 4.0.6) docker pull cassandra:4.0.6 Pour v\u00e9rifier que l'image est bien t\u00e9l\u00e9charg\u00e9e et inspecter sa taille : docker images | grep cassandra Ex\u00e9cuter un container docker run -d -p 9042 :9042 --name cassandra cassandra:4.0.6 V\u00e9rification \u00b6 Pour v\u00e9rifier que le container est en cours d'ex\u00e9cution : docker ps | grep cassandra Se connecter \u00e0 Cassandra Avec le shell cqlsh docker exec -it cassandra cqlsh D\u00e9marrer/Arr\u00eater Cassandra \u00b6 Maintenant, il est plus simple de d\u00e9marrer ou arr\u00eater Cassandra avec le container Docker d\u00e9j\u00e0 cr\u00e9\u00e9. Pour d\u00e9marrer : docker start cassandra Pour Arr\u00eater : docker stop cassandra Configuration \u00b6 L'emplacement des fichiers de configuration de Cassandra varie selon le type d'installation : Docker : le dossier /etc/cassandra Installation manuelle : le dossier conf dans le dossier d'installation Paquet deb ou rpm : dans /etc/cassandra Les fichiers de configuration sont : cassandra.yaml : fichier de configuration principal selon le langage YAML. cassandra-env.sh : les variables d'environnement sp\u00e9cifiques \u00e0 Cassandra. cassandra-rackdc.properties ou cassandra-topology.properties : configuration des Racks et Datacenter pour les noeuds logback.xml : configuration du logging jvm-* : configuration de la JVM commitlog_archiving.properties : param\u00e8tres d'archivage du commitlog Voici quelques param\u00e8tres \u00e0 renseigner dans le fichier cassandra.yaml : cluster_name : nom du cluster, identique pour les noeuds sur le m\u00eame cluster. seeds : liste des noeuds seed du cluster servant \u00e0 faciliter l'ajout de nouveaux noeuds. storage_port : par d\u00e9faut 7000. listen_address : adresse d'\u00e9coute du serveur. Par d\u00e9faut : localhost. native_transport_port : port utilis\u00e9 par les clients Cassandra comme le shell cqlsh ou le client Python. Par d\u00e9faut c'est le port 9042.","title":"Installation"},{"location":"installation.html#installation-de-cassandra","text":"","title":"Installation de Cassandra"},{"location":"installation.html#cassandra-avec-docker","text":"","title":"Cassandra avec Docker "},{"location":"installation.html#installation","text":"T\u00e9l\u00e9charger l'image officielle de Cassandra (ici la version 4.0.6) docker pull cassandra:4.0.6 Pour v\u00e9rifier que l'image est bien t\u00e9l\u00e9charg\u00e9e et inspecter sa taille : docker images | grep cassandra Ex\u00e9cuter un container docker run -d -p 9042 :9042 --name cassandra cassandra:4.0.6","title":"Installation"},{"location":"installation.html#verification","text":"Pour v\u00e9rifier que le container est en cours d'ex\u00e9cution : docker ps | grep cassandra Se connecter \u00e0 Cassandra Avec le shell cqlsh docker exec -it cassandra cqlsh","title":"V\u00e9rification"},{"location":"installation.html#demarrerarreter-cassandra","text":"Maintenant, il est plus simple de d\u00e9marrer ou arr\u00eater Cassandra avec le container Docker d\u00e9j\u00e0 cr\u00e9\u00e9. Pour d\u00e9marrer : docker start cassandra Pour Arr\u00eater : docker stop cassandra","title":"D\u00e9marrer/Arr\u00eater Cassandra"},{"location":"installation.html#configuration","text":"L'emplacement des fichiers de configuration de Cassandra varie selon le type d'installation : Docker : le dossier /etc/cassandra Installation manuelle : le dossier conf dans le dossier d'installation Paquet deb ou rpm : dans /etc/cassandra Les fichiers de configuration sont : cassandra.yaml : fichier de configuration principal selon le langage YAML. cassandra-env.sh : les variables d'environnement sp\u00e9cifiques \u00e0 Cassandra. cassandra-rackdc.properties ou cassandra-topology.properties : configuration des Racks et Datacenter pour les noeuds logback.xml : configuration du logging jvm-* : configuration de la JVM commitlog_archiving.properties : param\u00e8tres d'archivage du commitlog Voici quelques param\u00e8tres \u00e0 renseigner dans le fichier cassandra.yaml : cluster_name : nom du cluster, identique pour les noeuds sur le m\u00eame cluster. seeds : liste des noeuds seed du cluster servant \u00e0 faciliter l'ajout de nouveaux noeuds. storage_port : par d\u00e9faut 7000. listen_address : adresse d'\u00e9coute du serveur. Par d\u00e9faut : localhost. native_transport_port : port utilis\u00e9 par les clients Cassandra comme le shell cqlsh ou le client Python. Par d\u00e9faut c'est le port 9042.","title":"Configuration"},{"location":"interrogation.html","text":"Interrogation \u00b6 Objectifs Importer des donn\u00e9es \u00e0 partir de fichier CSV Cr\u00e9er des requ\u00eates CQL Comprendre le Partitionnement et le Clustering R\u00e9aliser des agr\u00e9gations Importer des donn\u00e9es \u00e0 partir de fichiers CSV \u00b6 T\u00e9l\u00e9charger l'archive contenant les donn\u00e9es T\u00e9l\u00e9charger l'archive restaurants.zip D\u00e9compresser le contenu Examiner le contenu des fichiers csv (voir ci-dessous) Il s'agit de donn\u00e9es concernant des restaurant de New York et les r\u00e9sultats des inspections r\u00e9alis\u00e9es \u00e0 ces derniers. Ces donn\u00e9es sont respectivement dans les fichiers restaurants.csv et restaurants_inspections.csv . Copier les fichiers CSV dans le container Cassandra docker cp restaurants.csv cassandra:/ docker cp restaurants_inspections.csv cassandra:/ Cr\u00e9er le Keyspace et les tables Se connecter \u00e0 Cassandra avec cqlsh docker exec -it cassandra cqlsh Cr\u00e9er le Keyspace CREATE KEYSPACE IF NOT EXISTS resto_NY WITH REPLICATION = { 'class' : 'SimpleStrategy' , 'replication_factor' : 1 } ; Cr\u00e9er les tables USE resto_NY ; CREATE TABLE Restaurant ( id INT , Name VARCHAR , borough VARCHAR , BuildingNum VARCHAR , Street VARCHAR , ZipCode INT , Phone text , CuisineType VARCHAR , PRIMARY KEY ( id ) ); CREATE INDEX fk_Restaurant_cuisine ON Restaurant ( CuisineType ); CREATE TABLE Inspection ( idRestaurant INT , InspectionDate date , ViolationCode VARCHAR , ViolationDescription VARCHAR , CriticalFlag VARCHAR , Score INT , GRADE VARCHAR , PRIMARY KEY ( idRestaurant , InspectionDate ) ); CREATE INDEX fk_Inspection_Restaurant ON Inspection ( Grade ); Importer les fichier CSV avec la commande COPY COPY Restaurant ( id , name , borough , buildingnum , street , zipcode , phone , cuisinetype ) FROM '/restaurants.csv' WITH DELIMITER = ',' AND SKIPROWS = 1 ; COPY Inspection ( idrestaurant , inspectiondate , violationcode , violationdescription , criticalflag , score , grade ) FROM '/restaurants_inspections.csv' WITH DELIMITER = ',' AND SKIPROWS = 1 ; DELIMITER est le s\u00e9parateur et SKIPROWS indique le nombre de lignes \u00e0 ignorer permettant ainsi d'ignorer l'ent\u00eate. V\u00e9rifier le nombre de lignes dans chaque table SELECT count ( * ) FROM restaurant ; SELECT count ( * ) FROM inspection ; Les r\u00e9ponses doivent \u00eatre respectivement 25624 et 149818 Format de la requ\u00eate SELECT \u00b6 select_statement :: = SELECT [ JSON | DISTINCT ] ( select_clause | '*' ) FROM ` table_name ` [ WHERE ` where_clause ` ] [ GROUP BY ` group_by_clause ` ] [ ORDER BY ` ordering_clause ` ] [ PER PARTITION LIMIT ( ` integer ` | ` bind_marker ` ) ] [ LIMIT ( ` integer ` | ` bind_marker ` ) ] [ ALLOW FILTERING ] select_clause :: = ` selector ` [ AS ` identifier ` ] ( ',' ` selector ` [ AS ` identifier ` ] ) selector :: == ` column_name ` | ` term ` | CAST '(' ` selector ` AS ` cql_type ` ')' | ` function_name ` '(' [ ` selector ` ( ',' ` selector ` ) _ ] ')' | COUNT '(' '_' ')' where_clause :: = ` relation ` ( AND ` relation ` ) * relation :: = column_name operator term '(' column_name ( ',' column_name ) * ')' operator tuple_literal TOKEN '(' column_name # ( ',' column_name ) * ')' operator term operator :: = '=' | '<' | '>' | '<=' | '>=' | '!=' | IN | CONTAINS | CONTAINS KEY group_by_clause :: = column_name ( ',' column_name ) * ordering_clause :: = column_name [ ASC | DESC ] ( ',' column_name [ ASC | DESC ] ) * Requ\u00eates simples \u00b6 Quel est le nom du retaurant ayant l'id 41692194 SELECT name FROM restaurant WHERE id = 41692194 ; Quel est le nom du retaurant ayant un id sup\u00e9rieur \u00e0 41692194 SELECT name FROM restaurant WHERE id > 41692194 ; Remarque Cette requ\u00eate provoque une erreur parce que Cassandra n'accepte que les conditions d'\u00e9galit\u00e9 sur la cl\u00e9 primaire. Ajouter ALLOW FILTERING pour l'ex\u00e9cuter. Quel est l'id du retaurant BANGKOK HOUSE SELECT id FROM restaurant WHERE name = 'BANGKOK HOUSE' ; Remarque Cette requ\u00eate provoque une erreur parce que Cassandra n'accepte que les conditions sur la cl\u00e9 primaire. Ajouter ALLOW FILTERING pour l'ex\u00e9cuter ou ajouter un index sur la colonne name. Quels sont les dates d'inspections du retaurant d'id = 41692194 SELECT inspectiondate FROM inspection WHERE idrestaurant = 41692194 ; Remarque Remarquez que les dates sont tri\u00e9es. Puisque c'est la cl\u00e9 de clustering. Trouver les restaurants inspect\u00e9s entre le 12/10/2016 et les 3 jours qui suivent (r\u00e9sultat au format JSON) SELECT JSON idrestaurant , inspectiondate FROM inspection WHERE inspectiondate >= '2016-10-12' and inspectiondate <= '2016-10-12' + 3 d ALLOW FILTERING ; Quels sont les jours de avril 2015 ayant au moins une inspection. SELECT distinct inspectiondate FROM inspection WHERE inspectiondate >= '2015-04-01' and inspectiondate <= '2015-04-30' ALLOW FILTERING ; Remarque DISTINCT ne peut \u00eatre utilis\u00e9 qu'avec des colonnes statique ou cl\u00e9 de partitionnement et le filtrage doit porter sur la cl\u00e9 de partitionnement. Quel est le nom des retaurants ayant re\u00e7u un grade de A le 14/10/2016 SELECT idrestaurant FROM inspection WHERE grade = 'A' AND inspectiondate = '2016-10-14' ; Remarque Pas de jointure dans Cassandra. Utiliser les types utilisateur et les collections pour avoir une mod\u00e9lisation d\u00e9normalis\u00e9e. Quels sont les retaurants ayant \u00e9t\u00e9 inspect\u00e9 le 14/10/2016 tri\u00e9s selon le score d\u00e9croissant SELECT idrestaurant , score FROM inspection WHERE inspectiondate = '2016-10-14' ORDER BY score ; Remarque ORDER BY ne peut \u00eatre qu'avec un filtrage sur la cl\u00e9 primaire avec = ou IN et sur la cl\u00e9 de clustering. Agr\u00e9gations \u00b6 Quel est le nombre de restaurant de MANHATTAN SELECT count ( * ) FROM restaurant WHERE borough = 'MANHATTAN' ALLOW FILTERING ; Quel est le nombre d'inspections par grade SELECT grade , count ( * ) as total FROM inspection GROUP BY grade ; Remarque GROUP BY ne peut \u00eatre utilis\u00e9 qu'avec les colonnes de la cl\u00e9 primaire. Quel est le nombre d'inspections par jour SELECT count ( * ) FROM inspection GROUP BY inspectiondate ; Remarque Les colonnes dans GROUP BY ne peuvent \u00eatre utilis\u00e9es que dans l'ordre de d\u00e9finition de la cl\u00e9 primaire. Quel est le nombre d'inspections par restaurant SELECT idrestaurant , count ( * ) as total FROM inspection GROUP BY idrestaurant ;","title":"Interrogation"},{"location":"interrogation.html#interrogation","text":"Objectifs Importer des donn\u00e9es \u00e0 partir de fichier CSV Cr\u00e9er des requ\u00eates CQL Comprendre le Partitionnement et le Clustering R\u00e9aliser des agr\u00e9gations","title":"Interrogation"},{"location":"interrogation.html#importer-des-donnees-a-partir-de-fichiers-csv","text":"T\u00e9l\u00e9charger l'archive contenant les donn\u00e9es T\u00e9l\u00e9charger l'archive restaurants.zip D\u00e9compresser le contenu Examiner le contenu des fichiers csv (voir ci-dessous) Il s'agit de donn\u00e9es concernant des restaurant de New York et les r\u00e9sultats des inspections r\u00e9alis\u00e9es \u00e0 ces derniers. Ces donn\u00e9es sont respectivement dans les fichiers restaurants.csv et restaurants_inspections.csv . Copier les fichiers CSV dans le container Cassandra docker cp restaurants.csv cassandra:/ docker cp restaurants_inspections.csv cassandra:/ Cr\u00e9er le Keyspace et les tables Se connecter \u00e0 Cassandra avec cqlsh docker exec -it cassandra cqlsh Cr\u00e9er le Keyspace CREATE KEYSPACE IF NOT EXISTS resto_NY WITH REPLICATION = { 'class' : 'SimpleStrategy' , 'replication_factor' : 1 } ; Cr\u00e9er les tables USE resto_NY ; CREATE TABLE Restaurant ( id INT , Name VARCHAR , borough VARCHAR , BuildingNum VARCHAR , Street VARCHAR , ZipCode INT , Phone text , CuisineType VARCHAR , PRIMARY KEY ( id ) ); CREATE INDEX fk_Restaurant_cuisine ON Restaurant ( CuisineType ); CREATE TABLE Inspection ( idRestaurant INT , InspectionDate date , ViolationCode VARCHAR , ViolationDescription VARCHAR , CriticalFlag VARCHAR , Score INT , GRADE VARCHAR , PRIMARY KEY ( idRestaurant , InspectionDate ) ); CREATE INDEX fk_Inspection_Restaurant ON Inspection ( Grade ); Importer les fichier CSV avec la commande COPY COPY Restaurant ( id , name , borough , buildingnum , street , zipcode , phone , cuisinetype ) FROM '/restaurants.csv' WITH DELIMITER = ',' AND SKIPROWS = 1 ; COPY Inspection ( idrestaurant , inspectiondate , violationcode , violationdescription , criticalflag , score , grade ) FROM '/restaurants_inspections.csv' WITH DELIMITER = ',' AND SKIPROWS = 1 ; DELIMITER est le s\u00e9parateur et SKIPROWS indique le nombre de lignes \u00e0 ignorer permettant ainsi d'ignorer l'ent\u00eate. V\u00e9rifier le nombre de lignes dans chaque table SELECT count ( * ) FROM restaurant ; SELECT count ( * ) FROM inspection ; Les r\u00e9ponses doivent \u00eatre respectivement 25624 et 149818","title":"Importer des donn\u00e9es \u00e0 partir de fichiers CSV"},{"location":"interrogation.html#format-de-la-requete-select","text":"select_statement :: = SELECT [ JSON | DISTINCT ] ( select_clause | '*' ) FROM ` table_name ` [ WHERE ` where_clause ` ] [ GROUP BY ` group_by_clause ` ] [ ORDER BY ` ordering_clause ` ] [ PER PARTITION LIMIT ( ` integer ` | ` bind_marker ` ) ] [ LIMIT ( ` integer ` | ` bind_marker ` ) ] [ ALLOW FILTERING ] select_clause :: = ` selector ` [ AS ` identifier ` ] ( ',' ` selector ` [ AS ` identifier ` ] ) selector :: == ` column_name ` | ` term ` | CAST '(' ` selector ` AS ` cql_type ` ')' | ` function_name ` '(' [ ` selector ` ( ',' ` selector ` ) _ ] ')' | COUNT '(' '_' ')' where_clause :: = ` relation ` ( AND ` relation ` ) * relation :: = column_name operator term '(' column_name ( ',' column_name ) * ')' operator tuple_literal TOKEN '(' column_name # ( ',' column_name ) * ')' operator term operator :: = '=' | '<' | '>' | '<=' | '>=' | '!=' | IN | CONTAINS | CONTAINS KEY group_by_clause :: = column_name ( ',' column_name ) * ordering_clause :: = column_name [ ASC | DESC ] ( ',' column_name [ ASC | DESC ] ) *","title":"Format de la requ\u00eate SELECT"},{"location":"interrogation.html#requetes-simples","text":"Quel est le nom du retaurant ayant l'id 41692194 SELECT name FROM restaurant WHERE id = 41692194 ; Quel est le nom du retaurant ayant un id sup\u00e9rieur \u00e0 41692194 SELECT name FROM restaurant WHERE id > 41692194 ; Remarque Cette requ\u00eate provoque une erreur parce que Cassandra n'accepte que les conditions d'\u00e9galit\u00e9 sur la cl\u00e9 primaire. Ajouter ALLOW FILTERING pour l'ex\u00e9cuter. Quel est l'id du retaurant BANGKOK HOUSE SELECT id FROM restaurant WHERE name = 'BANGKOK HOUSE' ; Remarque Cette requ\u00eate provoque une erreur parce que Cassandra n'accepte que les conditions sur la cl\u00e9 primaire. Ajouter ALLOW FILTERING pour l'ex\u00e9cuter ou ajouter un index sur la colonne name. Quels sont les dates d'inspections du retaurant d'id = 41692194 SELECT inspectiondate FROM inspection WHERE idrestaurant = 41692194 ; Remarque Remarquez que les dates sont tri\u00e9es. Puisque c'est la cl\u00e9 de clustering. Trouver les restaurants inspect\u00e9s entre le 12/10/2016 et les 3 jours qui suivent (r\u00e9sultat au format JSON) SELECT JSON idrestaurant , inspectiondate FROM inspection WHERE inspectiondate >= '2016-10-12' and inspectiondate <= '2016-10-12' + 3 d ALLOW FILTERING ; Quels sont les jours de avril 2015 ayant au moins une inspection. SELECT distinct inspectiondate FROM inspection WHERE inspectiondate >= '2015-04-01' and inspectiondate <= '2015-04-30' ALLOW FILTERING ; Remarque DISTINCT ne peut \u00eatre utilis\u00e9 qu'avec des colonnes statique ou cl\u00e9 de partitionnement et le filtrage doit porter sur la cl\u00e9 de partitionnement. Quel est le nom des retaurants ayant re\u00e7u un grade de A le 14/10/2016 SELECT idrestaurant FROM inspection WHERE grade = 'A' AND inspectiondate = '2016-10-14' ; Remarque Pas de jointure dans Cassandra. Utiliser les types utilisateur et les collections pour avoir une mod\u00e9lisation d\u00e9normalis\u00e9e. Quels sont les retaurants ayant \u00e9t\u00e9 inspect\u00e9 le 14/10/2016 tri\u00e9s selon le score d\u00e9croissant SELECT idrestaurant , score FROM inspection WHERE inspectiondate = '2016-10-14' ORDER BY score ; Remarque ORDER BY ne peut \u00eatre qu'avec un filtrage sur la cl\u00e9 primaire avec = ou IN et sur la cl\u00e9 de clustering.","title":"Requ\u00eates simples"},{"location":"interrogation.html#agregations","text":"Quel est le nombre de restaurant de MANHATTAN SELECT count ( * ) FROM restaurant WHERE borough = 'MANHATTAN' ALLOW FILTERING ; Quel est le nombre d'inspections par grade SELECT grade , count ( * ) as total FROM inspection GROUP BY grade ; Remarque GROUP BY ne peut \u00eatre utilis\u00e9 qu'avec les colonnes de la cl\u00e9 primaire. Quel est le nombre d'inspections par jour SELECT count ( * ) FROM inspection GROUP BY inspectiondate ; Remarque Les colonnes dans GROUP BY ne peuvent \u00eatre utilis\u00e9es que dans l'ordre de d\u00e9finition de la cl\u00e9 primaire. Quel est le nombre d'inspections par restaurant SELECT idrestaurant , count ( * ) as total FROM inspection GROUP BY idrestaurant ;","title":"Agr\u00e9gations"},{"location":"ldd_lmd.html","text":"Op\u00e9rations de base \u00b6 Objectifs Dans cette section, une partie du langage CQL (Cassandra Query Language) sera explor\u00e9e. CQL est assez proche du langage SQL. Nous examinons les commandes CQL qui permettent de : Cr\u00e9er une BD Cassandra Ins\u00e9rer et supprimer des donn\u00e9es Modifier les donn\u00e9es Objets Cassandra \u00b6 CQL permet d'organiser les donn\u00e9es en : Keyspace : C'est l'\u00e9quivalent de Bases de Donn\u00e9es. Il d\u00e9finit comment les donn\u00e9es sont r\u00e9pliqu\u00e9es dans le cluster. Table : Une table d\u00e9crit le sch\u00e9ma des donn\u00e9es qui sont r\u00e9parties en partitions. Ces derni\u00e8res contiennent des lignes form\u00e9es de colonnes. Les sch\u00e9mas des tables sont flexibles. Partition : C'est la premi\u00e8re partie de la cl\u00e9 primaire qui d\u00e9termine le noeud sur lequel une ligne est stock\u00e9e. Row : Une collection de colonnes identifi\u00e9e par une cl\u00e9 primaire unique compos\u00e9 de cl\u00e9 de partitonnement et une cl\u00e9 de clustering. Column : Donn\u00e9e \u00e9l\u00e9mentaire d'un type d\u00e9fini par le sch\u00e9ma. Langage de D\u00e9finition de Donn\u00e9es \u00b6 Syntaxe \u00b6 Keyspace Cr\u00e9ation CREATE KEYSPACE [ IF NOT EXISTS ] keyspace_name WITH options Modification ALTER KEYSPACE [ IF EXISTS ] keyspace_name WITH options Suppression DROP KEYSPACE [ IF EXISTS ] keyspace_name Table Cr\u00e9ation CREATE TABLE [ IF NOT EXISTS ] table_name '(' column_definition ( ',' column_definition ) * [ ',' PRIMARY KEY '(' primary_key ')' ] ')' [ WITH table_options ] column_definition :: = column_name cql_type [ STATIC ] [ PRIMARY KEY ] primary_key :: = partition_key [ ',' clustering_columns ] partition_key :: = column_name | '(' column_name ( ',' column_name ) * ')' clustering_columns :: = column_name ( ',' column_name ) * table_options : = : COMPACT STORAGE [ AND table_options ] | CLUSTERING ORDER BY '(' clustering_order ')' [ AND table_options ] | options clustering_order :: = column_name ( ASC | DESC ) ( ',' column_name ( ASC | DESC ) ) * Modification ALTER TABLE [ IF EXISTS ] table_name alter_table_instruction alter_table_instruction :: = ADD [ IF NOT EXISTS ] column_name cql_type ( ',' column_name cql_type ) * | DROP [ IF EXISTS ] column_name ( column_name ) * | RENAME [ IF EXISTS ] column_name to column_name ( AND column_name to column_name ) * | WITH option Suppression DROP TABLE [ IF EXISTS ] table_name Exemples \u00b6 CQLSH Les exemples suivants sont ex\u00e9cut\u00e9s \u00e0 partir du shell CQLSH. Cr\u00e9ation d'un Keyspace (BD) CREATE KEYSPACE IF NOT EXISTS ecole WITH REPLICATION = { 'class' : 'SimpleStrategy' , 'replication_factor' : 3 } ; Cette commande cr\u00e9e un Keyspace ecole avec un facteur de r\u00e9plication \u00e9gal \u00e0 3. Un avertissement sera affich\u00e9 quand le nombre de noeuds est inf\u00e9rieur au facteur de r\u00e9plication. S\u00e9lectionner le Keyspace USE ecole ; V\u00e9rifier l'invite du shell qui devient cqlsh:ecole> Cr\u00e9er les tables Nous pouvons maintenant cr\u00e9er les tables (ou Column Family sous Cassandra) Cours et Enseignant \u00e0 partir de notre sch\u00e9ma ecole : Cours ( idCours , Intitule, Responsable, Niveau, nbHeuresMax, Coeff) Enseignant ( idEnseignant , Nom, Prenom, statut) La requ\u00eate de cr\u00e9ation de la table Cours : CREATE TABLE Cours ( idCours INT , Intitule VARCHAR , Responsable INT , Niveau VARCHAR , nbHeuresMax INT , Coeff INT , PRIMARY KEY ( idCours ) ); La requ\u00eate de cr\u00e9ation de la table Enseignant : CREATE TABLE Enseignant ( idEnseignant INT , Nom VARCHAR , Prenom VARCHAR , PRIMARY KEY ( idEnseignant ) ); Afficher les propri\u00e9t\u00e9s du Keyspace DESCRIBE ecole ; Un exemple de r\u00e9sultat est donn\u00e9 ci-dessous : CREATE KEYSPACE ecole WITH replication = { 'class' : 'SimpleStrategy' , 'replication_factor' : '3' } AND durable_writes = true ; CREATE TABLE ecole . cours ( idcours int PRIMARY KEY , coeff int , intitule text , nbheuresmax int , niveau text , responsable int ) WITH additional_write_policy = '99p' AND bloom_filter_fp_chance = 0 . 01 AND caching = { 'keys' : 'ALL' , 'rows_per_partition' : 'NONE' } AND cdc = false AND comment = '' AND compaction = { 'class' : 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy' , 'max_threshold' : '32' , 'min_threshold' : '4' } AND compression = { 'chunk_length_in_kb' : '16' , 'class' : 'org.apache.cassandra.io.compress.LZ4Compressor' } AND crc_check_chance = 1 . 0 AND default_time_to_live = 0 AND extensions = {} AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND read_repair = 'BLOCKING' AND speculative_retry = '99p' ; CREATE TABLE ecole . enseignant ( idenseignant int PRIMARY KEY , nom text , prenom text ) WITH additional_write_policy = '99p' AND bloom_filter_fp_chance = 0 . 01 AND caching = { 'keys' : 'ALL' , 'rows_per_partition' : 'NONE' } AND cdc = false AND comment = '' AND compaction = { 'class' : 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy' , 'max_threshold' : '32' , 'min_threshold' : '4' } AND compression = { 'chunk_length_in_kb' : '16' , 'class' : 'org.apache.cassandra.io.compress.LZ4Compressor' } AND crc_check_chance = 1 . 0 AND default_time_to_live = 0 AND extensions = {} AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND read_repair = 'BLOCKING' AND speculative_retry = '99p' ; Ajouter une colonne Nous avons oublier de d\u00e9finir la colonne Statut. Pour l'ajouter, \u00e9crire la commande suivante : ALTER TABLE Enseignant ADD Statut VARCHAR ; Puis v\u00e9rifier avec : DESC Enseignant ; Cr\u00e9er un index Afin de permettre la recherche par enseignant responsable dans la table Cours, nous ajoutons un index sur la colonne Responsable : CREATE INDEX idx_Responsable ON Cours ( Responsable ); FOREIGN KEY Cassandra ne supporte pas les cl\u00e9s \u00e9trang\u00e8res. Langage de Manipulation de Donn\u00e9es \u00b6 Syntaxe \u00b6 Insertion INSERT INTO table_name ( names_values | json_clause ) [ IF NOT EXISTS ] [ USING update_parameter ( AND update_parameter ) * ] names_values :: = names VALUES tuple_literal json_clause :: = JSON string [ DEFAULT ( NULL | UNSET ) ] names :: = '(' column_name ( ',' column_name ) * ')' Modification UPDATE table_name [ USING update_parameter ( AND update_parameter ) * ] SET assignment ( ',' assignment ) * WHERE where_clause [ IF ( EXISTS | condition ( AND condition ) * ) ] update_parameter :: = ( TIMESTAMP | TTL ) ( integer | bind_marker ) assignment : simple_selection '=' term | column_name '=' column_name ( '+' | '-' ) term | column_name '=' list_literal '+' column_name simple_selection :: = column_name | column_name '[' term ']' | column_name '.' field_name condition :: = simple_selection operator term Suppression DELETE [ simple_selection ( ',' simple_selection ) ] FROM table_name [ USING update_parameter ( AND update_parameter # ) * ] WHERE where_clause [ IF ( EXISTS | condition ( AND condition ) * ) ] Exemples \u00b6 Insertion des donn\u00e9es INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 1 , 'Introduction aux Bases de Donnees' , 1 , 'M1' , 30 , 3 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 2 , 'Immeubles de Grandes Hauteurs' , 4 , 'M1' , 30 , 2 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 3 , 'Production et distribution de biens et de ser' , 5 , 'M1' , 30 , 2 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 4 , 'Bases de Donnees Avancees' , 1 , 'M2' , 30 , 5 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 5 , 'Architecture des Systemes Materiel' , 6 , 'M2' , 8 , 1 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 6 , 'IT Business / Introduction' , 7 , 'M2' , 20 , 3 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 7 , 'IT Business / Strategie et Management' , 8 , 'M2' , 10 , 1 ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 1 , 'Travers' , 'Nicolas' , 'Vacataire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 2 , 'Mourier' , 'Pascale' , 'Titulaire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 3 , 'Boisson' , 'Francois' , 'Vacataire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 4 , 'Mathieu' , 'Eric' , 'Titulaire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 5 , 'Chu' , 'Chengbin' , 'Titulaire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 6 , 'Boutin' , 'Philippe' , 'Titulaire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 7 , 'Escribe' , 'Julien' , 'Vacataire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 8 , 'Znaty' , 'David' , 'Vacataire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 9 , 'Abal-Kassim' , 'Cheik Ahamed' , 'Vacataire' ); V\u00e9rifier, par exemple, le contenu de la table enseignant : SELECT * FROM Enseignant ; Mise \u00e0 jour UPDATE Cours Set nbheuresmax = 10 WHERE idCours = 5 ; Modifier le nombre d'heures Max pour le cours 5. Suppression DELETE FROM Cours WHERE idCours in ( 1 , 3 , 5 ); Supprimer les cours de codes 1, 3 et 5.","title":"Op\u00e9rations de base"},{"location":"ldd_lmd.html#operations-de-base","text":"Objectifs Dans cette section, une partie du langage CQL (Cassandra Query Language) sera explor\u00e9e. CQL est assez proche du langage SQL. Nous examinons les commandes CQL qui permettent de : Cr\u00e9er une BD Cassandra Ins\u00e9rer et supprimer des donn\u00e9es Modifier les donn\u00e9es","title":"Op\u00e9rations de base"},{"location":"ldd_lmd.html#objets-cassandra","text":"CQL permet d'organiser les donn\u00e9es en : Keyspace : C'est l'\u00e9quivalent de Bases de Donn\u00e9es. Il d\u00e9finit comment les donn\u00e9es sont r\u00e9pliqu\u00e9es dans le cluster. Table : Une table d\u00e9crit le sch\u00e9ma des donn\u00e9es qui sont r\u00e9parties en partitions. Ces derni\u00e8res contiennent des lignes form\u00e9es de colonnes. Les sch\u00e9mas des tables sont flexibles. Partition : C'est la premi\u00e8re partie de la cl\u00e9 primaire qui d\u00e9termine le noeud sur lequel une ligne est stock\u00e9e. Row : Une collection de colonnes identifi\u00e9e par une cl\u00e9 primaire unique compos\u00e9 de cl\u00e9 de partitonnement et une cl\u00e9 de clustering. Column : Donn\u00e9e \u00e9l\u00e9mentaire d'un type d\u00e9fini par le sch\u00e9ma.","title":"Objets Cassandra"},{"location":"ldd_lmd.html#langage-de-definition-de-donnees","text":"","title":"Langage de D\u00e9finition de Donn\u00e9es"},{"location":"ldd_lmd.html#syntaxe","text":"Keyspace Cr\u00e9ation CREATE KEYSPACE [ IF NOT EXISTS ] keyspace_name WITH options Modification ALTER KEYSPACE [ IF EXISTS ] keyspace_name WITH options Suppression DROP KEYSPACE [ IF EXISTS ] keyspace_name Table Cr\u00e9ation CREATE TABLE [ IF NOT EXISTS ] table_name '(' column_definition ( ',' column_definition ) * [ ',' PRIMARY KEY '(' primary_key ')' ] ')' [ WITH table_options ] column_definition :: = column_name cql_type [ STATIC ] [ PRIMARY KEY ] primary_key :: = partition_key [ ',' clustering_columns ] partition_key :: = column_name | '(' column_name ( ',' column_name ) * ')' clustering_columns :: = column_name ( ',' column_name ) * table_options : = : COMPACT STORAGE [ AND table_options ] | CLUSTERING ORDER BY '(' clustering_order ')' [ AND table_options ] | options clustering_order :: = column_name ( ASC | DESC ) ( ',' column_name ( ASC | DESC ) ) * Modification ALTER TABLE [ IF EXISTS ] table_name alter_table_instruction alter_table_instruction :: = ADD [ IF NOT EXISTS ] column_name cql_type ( ',' column_name cql_type ) * | DROP [ IF EXISTS ] column_name ( column_name ) * | RENAME [ IF EXISTS ] column_name to column_name ( AND column_name to column_name ) * | WITH option Suppression DROP TABLE [ IF EXISTS ] table_name","title":"Syntaxe"},{"location":"ldd_lmd.html#exemples","text":"CQLSH Les exemples suivants sont ex\u00e9cut\u00e9s \u00e0 partir du shell CQLSH. Cr\u00e9ation d'un Keyspace (BD) CREATE KEYSPACE IF NOT EXISTS ecole WITH REPLICATION = { 'class' : 'SimpleStrategy' , 'replication_factor' : 3 } ; Cette commande cr\u00e9e un Keyspace ecole avec un facteur de r\u00e9plication \u00e9gal \u00e0 3. Un avertissement sera affich\u00e9 quand le nombre de noeuds est inf\u00e9rieur au facteur de r\u00e9plication. S\u00e9lectionner le Keyspace USE ecole ; V\u00e9rifier l'invite du shell qui devient cqlsh:ecole> Cr\u00e9er les tables Nous pouvons maintenant cr\u00e9er les tables (ou Column Family sous Cassandra) Cours et Enseignant \u00e0 partir de notre sch\u00e9ma ecole : Cours ( idCours , Intitule, Responsable, Niveau, nbHeuresMax, Coeff) Enseignant ( idEnseignant , Nom, Prenom, statut) La requ\u00eate de cr\u00e9ation de la table Cours : CREATE TABLE Cours ( idCours INT , Intitule VARCHAR , Responsable INT , Niveau VARCHAR , nbHeuresMax INT , Coeff INT , PRIMARY KEY ( idCours ) ); La requ\u00eate de cr\u00e9ation de la table Enseignant : CREATE TABLE Enseignant ( idEnseignant INT , Nom VARCHAR , Prenom VARCHAR , PRIMARY KEY ( idEnseignant ) ); Afficher les propri\u00e9t\u00e9s du Keyspace DESCRIBE ecole ; Un exemple de r\u00e9sultat est donn\u00e9 ci-dessous : CREATE KEYSPACE ecole WITH replication = { 'class' : 'SimpleStrategy' , 'replication_factor' : '3' } AND durable_writes = true ; CREATE TABLE ecole . cours ( idcours int PRIMARY KEY , coeff int , intitule text , nbheuresmax int , niveau text , responsable int ) WITH additional_write_policy = '99p' AND bloom_filter_fp_chance = 0 . 01 AND caching = { 'keys' : 'ALL' , 'rows_per_partition' : 'NONE' } AND cdc = false AND comment = '' AND compaction = { 'class' : 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy' , 'max_threshold' : '32' , 'min_threshold' : '4' } AND compression = { 'chunk_length_in_kb' : '16' , 'class' : 'org.apache.cassandra.io.compress.LZ4Compressor' } AND crc_check_chance = 1 . 0 AND default_time_to_live = 0 AND extensions = {} AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND read_repair = 'BLOCKING' AND speculative_retry = '99p' ; CREATE TABLE ecole . enseignant ( idenseignant int PRIMARY KEY , nom text , prenom text ) WITH additional_write_policy = '99p' AND bloom_filter_fp_chance = 0 . 01 AND caching = { 'keys' : 'ALL' , 'rows_per_partition' : 'NONE' } AND cdc = false AND comment = '' AND compaction = { 'class' : 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy' , 'max_threshold' : '32' , 'min_threshold' : '4' } AND compression = { 'chunk_length_in_kb' : '16' , 'class' : 'org.apache.cassandra.io.compress.LZ4Compressor' } AND crc_check_chance = 1 . 0 AND default_time_to_live = 0 AND extensions = {} AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND read_repair = 'BLOCKING' AND speculative_retry = '99p' ; Ajouter une colonne Nous avons oublier de d\u00e9finir la colonne Statut. Pour l'ajouter, \u00e9crire la commande suivante : ALTER TABLE Enseignant ADD Statut VARCHAR ; Puis v\u00e9rifier avec : DESC Enseignant ; Cr\u00e9er un index Afin de permettre la recherche par enseignant responsable dans la table Cours, nous ajoutons un index sur la colonne Responsable : CREATE INDEX idx_Responsable ON Cours ( Responsable ); FOREIGN KEY Cassandra ne supporte pas les cl\u00e9s \u00e9trang\u00e8res.","title":"Exemples"},{"location":"ldd_lmd.html#langage-de-manipulation-de-donnees","text":"","title":"Langage de Manipulation de Donn\u00e9es"},{"location":"ldd_lmd.html#syntaxe_1","text":"Insertion INSERT INTO table_name ( names_values | json_clause ) [ IF NOT EXISTS ] [ USING update_parameter ( AND update_parameter ) * ] names_values :: = names VALUES tuple_literal json_clause :: = JSON string [ DEFAULT ( NULL | UNSET ) ] names :: = '(' column_name ( ',' column_name ) * ')' Modification UPDATE table_name [ USING update_parameter ( AND update_parameter ) * ] SET assignment ( ',' assignment ) * WHERE where_clause [ IF ( EXISTS | condition ( AND condition ) * ) ] update_parameter :: = ( TIMESTAMP | TTL ) ( integer | bind_marker ) assignment : simple_selection '=' term | column_name '=' column_name ( '+' | '-' ) term | column_name '=' list_literal '+' column_name simple_selection :: = column_name | column_name '[' term ']' | column_name '.' field_name condition :: = simple_selection operator term Suppression DELETE [ simple_selection ( ',' simple_selection ) ] FROM table_name [ USING update_parameter ( AND update_parameter # ) * ] WHERE where_clause [ IF ( EXISTS | condition ( AND condition ) * ) ]","title":"Syntaxe"},{"location":"ldd_lmd.html#exemples_1","text":"Insertion des donn\u00e9es INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 1 , 'Introduction aux Bases de Donnees' , 1 , 'M1' , 30 , 3 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 2 , 'Immeubles de Grandes Hauteurs' , 4 , 'M1' , 30 , 2 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 3 , 'Production et distribution de biens et de ser' , 5 , 'M1' , 30 , 2 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 4 , 'Bases de Donnees Avancees' , 1 , 'M2' , 30 , 5 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 5 , 'Architecture des Systemes Materiel' , 6 , 'M2' , 8 , 1 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 6 , 'IT Business / Introduction' , 7 , 'M2' , 20 , 3 ); INSERT INTO Cours ( idCours , Intitule , Responsable , Niveau , nbHeuresMax , Coeff ) VALUES ( 7 , 'IT Business / Strategie et Management' , 8 , 'M2' , 10 , 1 ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 1 , 'Travers' , 'Nicolas' , 'Vacataire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 2 , 'Mourier' , 'Pascale' , 'Titulaire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 3 , 'Boisson' , 'Francois' , 'Vacataire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 4 , 'Mathieu' , 'Eric' , 'Titulaire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 5 , 'Chu' , 'Chengbin' , 'Titulaire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 6 , 'Boutin' , 'Philippe' , 'Titulaire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 7 , 'Escribe' , 'Julien' , 'Vacataire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 8 , 'Znaty' , 'David' , 'Vacataire' ); INSERT INTO Enseignant ( idEnseignant , Nom , Prenom , statut ) VALUES ( 9 , 'Abal-Kassim' , 'Cheik Ahamed' , 'Vacataire' ); V\u00e9rifier, par exemple, le contenu de la table enseignant : SELECT * FROM Enseignant ; Mise \u00e0 jour UPDATE Cours Set nbheuresmax = 10 WHERE idCours = 5 ; Modifier le nombre d'heures Max pour le cours 5. Suppression DELETE FROM Cours WHERE idCours in ( 1 , 3 , 5 ); Supprimer les cours de codes 1, 3 et 5.","title":"Exemples"},{"location":"python.html","text":"Client Python pour Cassandra \u00b6 Pr\u00e9requis La base de donn\u00e9es de la section interrogation est import\u00e9e D\u00e9marrer le container cassandra (port 9042 doit \u00eatre publi\u00e9) Objectifs Se connecter \u00e0 Cassandra avec le pilote PYthon Ex\u00e9cuter des requ\u00eates vers Cassandra et r\u00e9cup\u00e9rer leurs r\u00e9sultats avec Python \u00c0 faire T\u00e9l\u00e9charger le notebook jupyter ( cassandraPython.ipynb ) ci-dessous et tester le code.","title":"Client Python pour Cassandra"},{"location":"python.html#client-python-pour-cassandra","text":"Pr\u00e9requis La base de donn\u00e9es de la section interrogation est import\u00e9e D\u00e9marrer le container cassandra (port 9042 doit \u00eatre publi\u00e9) Objectifs Se connecter \u00e0 Cassandra avec le pilote PYthon Ex\u00e9cuter des requ\u00eates vers Cassandra et r\u00e9cup\u00e9rer leurs r\u00e9sultats avec Python \u00c0 faire T\u00e9l\u00e9charger le notebook jupyter ( cassandraPython.ipynb ) ci-dessous et tester le code.","title":"Client Python pour Cassandra"}]}